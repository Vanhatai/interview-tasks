# С1.6 Пишем собственные методы 

Вы уже успели поработать с jQuery, так как это библиотека, написанная на __Javascript__ поэтому мы можем написать похожую реализацию сами. Давайте посмотрим, как же можно самостоятельно реализовать функционал, похожий на популярную библиотеку. 

У нас будет совсем маленькая библиотека, поэтому и название у нее будет соответсвующее - `ʲᵠᵘᵉʳʸ`. Начнем с самого простого, `$('selector')` должна нам вернуть элемент. Мы уже работали с __DOM__, поэтому не должно составить труда написать конструкцию, похожую на:

```javascript
function ʲᵠᵘᵉʳʸ (element) {
	return document.querySelector(element);
}
```

Почему мы не использовали стрелочную функцию? Такую функцию мы не сможем вызвать через `new`, а также у нее есть еще ряд ограничений. Если вы еще не прочитали статью на __MDN__, то настоятельно рекомендую к [ознакомлению](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions).

Давайте теперь напишем свой собственный метод для того, чтобы получать коллекцию элементов, вместо одного. Логично будет назвать этот метод all. Обязательно создавайте метод в __prototype__! Не стоит определять напрямую (в нашем случае - `ʲᵠᵘᵉʳʸ.all`).

Создавать метод в конструкторе, значит создавать новую копию функции для каждого нового экземпляра класса. Создав 5 экземпляров класса, мы получим 5 одинаковых функций.
Записывая метод в prototype, мы не присваиваем его непосредственно объекту. Метод окажется в свойстве __proto__ созданного экземпляра. 

Каждый экземпляр нашего класса имеет свойство __proto__ и это свойство у каждого экземпляра ссылается на __один__ и то тот же объект, в который мы и записали наш метод, используя __prtototype__. Такми образом, записав функцию `all()` в prototype и потом создав 5 экземпляров класса, мы получим всего одну функцию `all()`, сохраненную в __proto__. Все созданные объекты будут использовать эту функцию, хранящуюся в общем месте, либо по умному - [SSOT](https://en.wikipedia.org/wiki/Single_source_of_truth).

Давайте уже напишем свой первый метод!

```javascript
ʲᵠᵘᵉʳʸ.prototype.all = function (elements) {
	return document.querySelectorAll(elements);
}
```

Теперь, чтобы получить коллекцию элементов мы можем вызвать `ʲᵠᵘᵉʳʸ.all('selector')` и наш первый метод будет корректно работать. 

Абзацем выше я затронул тему __экземпляров__ класса. Это такой вызов нашей функции, который осуществляется с помощью оператора `new`. Допустим - `new ʲᵠᵘᵉʳʸ('#div')`;

Давайте теперь разберем немного ООП. Первой важной вещью в ООП является __наследование__. Его можно наблюдать и в жизни -

График из википедии https://ru.wikipedia.org/wiki/%D0%A6%D0%B0%D1%80%D1%81%D1%82%D0%B2%D0%BE_(%D0%B1%D0%B8%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F)

Наследование в JS проще всего реализуется с помощью `extends` или по русски - *расширять*. Мы будем расширять наш объект методами из родительской функции или объекта. В нашем примере это будет выглядеть так - 

```javascript
class $ extends ʲᵠᵘᵉʳʸ {
  constructor() {
    super();
  }
}
```
https://jsfiddle.net/4xhoay6p/


ДЗ
1) 

```javascript

```

2) 
```javascript

```
