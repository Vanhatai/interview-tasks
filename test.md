# С1.4 Стрелочные функции 

В JavaScript есть множество способов для объявления функций, но в этом уроке мы разберем только самые используемые спопсобы, которые покрывают 99% необходимых случаев.

Для единоразового вызова функции можно использовать __IIFE__.

__IIFE (Immediately Invoked Function Expression)__ это __JavaScript__ функция, которая выполнится сразу же после того, как она была определена в вашем коде. Обычно используется для того, чтобы выполнить определенные расчеты не засоряю глобальную область видимости.

__IIFE__ обычно выглядит так:
```javascript
(function (params) {
    //...code
})(arguments);
```

Для написания IIFE мы должны обернуть нашу функцию в скобки, а аргументы передать  в скобки, следующие сразу после функции. Давайте посмотрим как будет выглядеть одинаковый код с __IIFE__ и обычной функцией:

```javascript
(function (a, b) {
    return a + b; // 4
})(2,2);

function foo(a, b) {
    return a + b; // 4
};

foo(2,2);
```

В данном синтетическом примере можно увидеть, что первый способ выглядит компактнее и нагляднее. Также есть возможность уменьшить количество символов, используя __стрелочные функции (Arrow functions)__. __Стрелочные функции__ чем-то схожи с синтаксисом [Lambda функций](https://python-scripts.com/no-lambda). Сигнатура функций, аналогичных для примера выше может выглядеть вот так: 

```javascript
((a, b)=> a + b)(2,2); // 4

const foo = (a, b) => a + b; // 4

foo(2,2);
```

У стрелочных функций есть различные вариации написания и особенности, которые обязательно следует знать.

```javascript
// У выражения с одним аргументом можно опустить написание скобок
const foo = a => a + a;

// У выражения без аргументов нужно обязательно писать скобки
const bar = () => 2 + 2;
//Либо можно написать аргумент, который не будет использован, например так - 
const bar2 = _ => 2 + 2;

/* Очень длинное выражение можно писать в несколько строк
 * но обязательно стоит указать что именно нужно вернуть
 * иначе функция ничего не вернет
*/
const baz = (a, b) => {
  const temp = a;
  return temp + b;
}
```

Очень часто __стрелочные функции__ используются внутри методов, например, чтобы перебрать массив удобнее использовать __стрелочную функцию__. Давайте разберем как это сделать на очень частом примере, где нам следует получить новый массив из данного:

```javascript
const array = [1, 2, 3, 4];

const newArray = array.map( (number, index) => number * index ); // [0, 2, 6, 12]
```

Для перебора массив мы использовали метод [map()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/map). Этот метод перебирает заданный массив и возвращает новый, поэтому мы присвоили результат выполнения функции нашей переменной. Внутри метода `map` мы использовали стрелочную функцию, которая получает первым аргументом число, а вторым индекс. Таким образом данная запись намного короче аналогичных и более выразительная.


В дальнейшем мы рассмотрим асинхронные функции, функции с необязательными параметрами и генераторы. Но если вам интересно, то вы можете прочитать про них прямо сейчас
* [Async function](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/async_function)
* [Function with rest parametrs](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Rest_parameters)
* [Functions generators](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Generator)


ДЗ
1) Создать массив значений Фаренгейта из массива значений Цельсия

```javascript
const celsius = [-15, -5, 0, 10, 16, 20, 24, 32];

const rate = value => value * 1.8 + 32;

const fahrenheit = celsius.___(t => rate(_));
```

2) Поиск пересечений в массивах (A ∩ B)
```javascript
const firstArr = [1, 4, 3, 2];
const secondArr = [5, 2, 6, 7, 1];

const output = firstArr.___(value => _______.includes(value)); // Вернет [1, 2]
```
